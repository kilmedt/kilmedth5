不同函数的变量无法互相访问。
复合语句内定义的变量无法在语句外访问。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern关键字
e.g.
#include <stdio.h>

void func();
void func(){
    extern count++;
    //extern告诉编译器：这个变量我在后面定义了，你先别急着报错
}
// 全局变量count
int count = 0;
int main()
{
    ...
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
！！不要大量的使用全局变量：使用全局变量会使程序占用更多的内存；会提高程序的耦合性（牵一发而动全身）；污染命名空间。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
作用域：
代码块作用域{}
文件作用域
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
定义：当一个变量被定义时，编译器为变量申请内存空间并填充一些值。
声明：当一个变量被声明时，编译器就知道该变量被定义在其他地方。
局部变量既是定义又是声明；
static会将全局变量由external属性变为internal属性。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
存储类型
auto自动变量 （默认的存储类型）
register寄存器变量  存储在CPU的寄存器中（当变量声明为寄存器变量时，无法通过取地址获得该变量的地址。）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
动态内存管理1
malloc：mallocc函数向系统申请分配size个字节的空间，并返回一个指向这块空间的指针。
   void *malloc(size_t size);
函数调用失败返回null

free:释放ptr参数指向的内存空间。该空间必须由malloc,calloc,realloc函数申请的。
   void free(void *ptr);
！！及时释放内存，避免内存泄漏 ！！
！！防止丢失内存块地址 ！！
~~~~~~~~~~~~~~~~~~~~~~~~~
初始化内存空间
以mem开头，包含在string.h中
   memset--使用一个常量字节填充内存空间
   memcpy--拷贝内存空间
   memmove--移动内存空间
   memcmp--比较内存空间
   memchr--在内存空间中搜索一个字符                                                                    
calloc:申请完内存空间后，自动初始化该内存空间为零。
   void *calloc（size_t nmemb,size_t size); 
realloc:重新分配内存
   void *realloc(size_t size1,size_t size2);
~~~~~~~~~~~~~~~~~~~~~~~~
高级宏定义
不带参数的宏定义
//基础宏定义
   #define PI 3.14      
#undef可以终止宏定义的作用域
宏定义允许嵌套
带参数的宏定义
   #define NAME(参数) 表达式
内联函数(提高程序效率，但会增加编译时间)
关键字 inline
   inline int square(int);
   inline int square(int x){

   }
编译器会自动优化可以内联的函数
预处理运算符：# 和 ##
在参宏定义中，#运算符后跟一个参数，预处理器会把他转换为字符串。
## 记号链接运算符 比如链接两个参数
可变参数
   #define SHOWLIST(...) printf(#__VA_ARGS__)
~~~~~~~~~~~~~~~~~~~~~~~
结构体
声明
   struct 结构体名称(第一个字母大写)
   {
      结构体成员1；
      结构体成员2；
      结构体成员3；
      ...
   };
定义结构体类型变量
   struct 结构体名称 结构体变量名
访问结构体变量
   需要（.）点号运算符
   book.title
   book.price
   ...
初始化结构体变量
   struct Book book = {
      "...",
      "...",
      ...,
      ...,
      ...
   };
可以通过（.）指定成员值
   struct Book book = {.price = 48.8};
